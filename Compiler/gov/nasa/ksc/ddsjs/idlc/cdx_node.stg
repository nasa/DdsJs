// StringTemplate group file used to generate Node.js C++ add-on code from IDL.

delimiters "%", "%"

top_level(options,topModule) ::= <<
// ----------------------------------------------------------------------------
// This code was automatically generated by the DDS.js compiler. Do not edit
// by hand as changes will be lost during recompilation.
// Generated on: %options.generatedDateString%
// ----------------------------------------------------------------------------

%file_header(options)%
%module_code(topModule,options,true)%
%file_footer(topModule, options)%
>>

file_header(options) ::= <<
%if(!options.cppOutput)%
#ifndef %options.outputFileNameHeaderGuard%
# define %options.outputFileNameHeaderGuard%

%else%
#include <cmath>
#include <string>
#include <sstream>

%endif%
#include <v8.h>
#include <node.h>
#include <node_object_wrap.h>

%if(options.noCdxjsTopLevelInc)%
#include <DdsJs/coredx_missing.hh>
#include <DdsJs/TypeUtility.hh>

%else%
#include <DdsJs/ddsjs.hh>

%endif%

%if(!options.noDdsCppHeader)%
#include "%options.inputFileNameBase%.hh"
#include "%options.inputFileNameBase%DataReader.hh"
#include "%options.inputFileNameBase%DataWriter.hh"
#include "%options.inputFileNameBase%TypeSupport.hh"
%endif%

%if(!options.headerOutput)%
#include "%options.headerFileName%"

%endif%
%if(options.cppOutput)%
using std::string;
using std::stringstream;
using v8::Object;
using v8::Value;
using v8::String;
using v8::FunctionTemplate;
using v8::Number;
using v8::Persistent;
using v8::Local;
using v8::HandleScope;
using v8::Null;
using v8::Undefined;
using v8::Function;
using v8::Array;
using v8::TryCatch;
using v8::Context;
using v8::Integer;
using v8::Isolate;
using v8::EscapableHandleScope;
using v8::FunctionCallbackInfo;
using v8::MaybeLocal;
using v8::Exception;
using v8::Maybe;
using node::ObjectWrap;
using DDS::Topic;
using DDS::ReturnCode_t;
using DDS::DomainParticipant;
using DDS::SampleInfoSeq;
using DDS::Subscriber;
using DDS::TopicDescription;
using DDS::ReadCondition;
using DDS::WaitSet;
using DDS::ConditionSeq;
using DDS::Duration_t;
using DDS::Condition;
using DDS::Publisher;

%endif%
>>

file_footer(topModule, options) ::= <<
%if(options.cppOutput && !options.noNodeJsInit)%
NODE_MODULE(%options.nodeJsModuleName%, %topModule.moduleName%::InitAll)
%endif%
%if(!options.cppOutput)%
#endif /* %options.outputFileNameHeaderGuard% */
%endif%

>>

module_code(moduleObj,options,topLevel) ::= <<
// ======================================================
// MODULE DECLARATION: %moduleObj.moduleName%
// ======================================================
namespace %moduleObj.moduleName% {

%if(options.headerOutput)%
%moduleObj.childModules:module_code(options,false)%
%moduleObj.enumDefinitions:enum_decl()%
%moduleObj.unionDefinitions:union_decl()%
%moduleObj.topicDefinitions:struct_decl(options)%
%endif%
%if(options.cppOutput)%
%if(!options.headerOutput)%
%moduleObj.childModules:module_code(options, false)%
%endif%
%moduleObj.enumDefinitions:enum_impl()%
%moduleObj.unionDefinitions:union_impl()%
%moduleObj.topicDefinitions:struct_impl(options)%
%endif%
// ======================================================
// MODULE INITIALIZATION: %moduleObj.moduleName%
// ======================================================
%if(options.headerOutput)%
void InitAll(::v8::Local< ::v8::Object > exports);
%endif%

%if(options.cppOutput)%
void InitAll(Local<Object> exports)
{
	Isolate *isolate = Isolate::GetCurrent();
	Local<Object> moduleExports(Object::New(isolate));
	Maybe< bool > setResult = exports->Set(
		isolate->GetCurrentContext(),
		String::NewFromUtf8(
			isolate,
			"%moduleObj.moduleName%"
		),
		moduleExports
	);
	
	if (!setResult.FromMaybe(false))
	{
		// TODO: Throw exception
	}
	
	//
	// Constant Expressions
	//
	%moduleObj.constantExpressions:constant_expr_def()%
	
	//
	// Enum Initializations
	//
	%moduleObj.enumDefinitions:{ anEnum | %cpp_scoped_name(anEnum.owningModule,anEnum.enumName)%Field::Init(moduleExports);
	}%
	
	//
	// Union Initializations
	//
	%moduleObj.unionDefinitions:{ aUnion | %cpp_scoped_name(aUnion.owningModule,aUnion.unionName)%Field::Init(moduleExports);
	}%
	
	//
	// Struct/Topic Initializations
	//
	%moduleObj.topicDefinitions:struct_init(options)%
	
	//
	// Child Module Initialization
	//
	%moduleObj.childModules:{ childMod | %cpp_scoped_name(childMod,"InitAll")%(moduleExports);
	}%
	
	%if(topLevel && !moduleObj.moduleNameDds)%
	// Module name: %moduleObj.moduleName%
	::DdsJs::InitAll(exports);
	%endif%
}

%endif%

} // end namespace %moduleObj.moduleName%

>>

constant_expr_def(constDef) ::= <<
moduleExports->DefineOwnProperty(isolate->GetCurrentContext(),
	String::NewFromUtf8(isolate, "%constDef.identifier%"),
	%const_value(constDef)%,
	::v8::ReadOnly).Check();

>>

const_value(constDef) ::= "%({const_value_%constDef.constantType.idlTypeClass%})(constDef)%"

const_value_string(constDef) ::= "String::NewFromUtf8(isolate, %cpp_scoped_name(constDef.owningModule,constDef.identifier)%)"

const_value_boolean(constDef) ::= "Boolean::New(isolate, %cpp_scoped_name(constDef.owningModule,constDef.identifier)%)"

const_value_octet(constDef) ::= "Number::New(isolate, %cpp_scoped_name(constDef.owningModule,constDef.identifier)%)"

const_value_short(constDef) ::= "Number::New(isolate, %cpp_scoped_name(constDef.owningModule,constDef.identifier)%)"

const_value_unsigned_short(constDef) ::= "Number::New(isolate, %cpp_scoped_name(constDef.owningModule,constDef.identifier)%)"

const_value_long(constDef) ::= "Number::New(isolate, %cpp_scoped_name(constDef.owningModule,constDef.identifier)%)"

const_value_unsigned_long(constDef) ::= "Number::New(isolate, %cpp_scoped_name(constDef.owningModule,constDef.identifier)%)"

const_value_float(constDef) ::= "Number::New(isolate, %cpp_scoped_name(constDef.owningModule,constDef.identifier)%)"

const_value_double(constDef) ::= "Number::New(isolate, %cpp_scoped_name(constDef.owningModule,constDef.identifier)%)"

enum_decl(enumDef) ::= <<
// ======================================================
// ENUM DECLARATION: %enumDef.enumName%
// ======================================================
struct %enumDef.enumName%Field
{
	typedef %cpp_scoped_name(enumDef.owningModule,enumDef.enumName)% ValueType;
	typedef %cpp_scoped_name(enumDef.owningModule,enumDef.enumName)%& RefType;
	typedef %cpp_scoped_name(enumDef.owningModule,enumDef.enumName)% const& ConstRefType;
	typedef %cpp_scoped_name(enumDef.owningModule,enumDef.enumName)% *PtrType;
	
	static void Init(::v8::Local< ::v8::Object > exports);
	static ::v8::Local< ::v8::Value > FromCppToJsValue(ConstRefType cppValue);
	static bool FromJsValueToCpp(::v8::Local< ::v8::Value > jsVal, RefType cppValueRet);
};

>>

enum_impl(enumDef) ::= <<
// ======================================================
// ENUM IMPLEMENTATION: %enumDef.enumName%
// ======================================================
%enum_impl_init(enumDef)%
%enum_impl_from_cpp(enumDef)%
%enum_impl_from_js(enumDef)%
>>

enum_impl_init(enumDef) ::= <<
// Initialization of enumeration %enumDef.enumName% field type
void %enumDef.enumName%Field::Init(Local<Object> exports)
{
	Isolate *isolate = Isolate::GetCurrent();
	Local<Context> ctx = Local<Context>::New(
		isolate,
		isolate->GetCurrentContext()
	);
	Local<Object> enumObj(Object::New(isolate));
	
	%enumDef.enumConstants:enum_impl_init_constant(enumDef)%
	
	Maybe< bool > setResult = exports->Set(
		ctx,
		String::NewFromUtf8(isolate, "%enumDef.enumName%"),
		enumObj
	);

	if (!setResult.FromMaybe(false))
	{
		// TODO: Throw exception
	}
}

>>

enum_impl_init_constant(enumConst,enumDef) ::= <<
enumObj->DefineOwnProperty(ctx,
	String::NewFromUtf8(isolate, "%enumConst.identifier%"),
	Number::New(isolate, %cpp_scoped_name(enumDef.owningModule,enumConst.identifier)%),
	::v8::ReadOnly).Check();

>>

enum_impl_from_cpp(enumDef) ::= <<
// From C++ to JavaScript for enum %enumDef.enumName%
Local<Value> %enumDef.enumName%Field::FromCppToJsValue(%enumDef.enumName%Field::ConstRefType cppValue)
{
	Isolate *isolate = Isolate::GetCurrent();
	EscapableHandleScope scope(isolate);
	
	return scope.Escape(::DdsJs::LongField::FromCppToJsValue(static_cast< ::DdsJs::LongField::ValueType >(cppValue)));
}

>>

enum_impl_from_js(enumDef) ::= <<
// From JavaScript to C++ for enum %enumDef.enumName%
bool %enumDef.enumName%Field::FromJsValueToCpp(Local<Value> jsVal, %enumDef.enumName%Field::RefType cppValueRet)
{
	::DdsJs::LongField::ValueType longVal;
	bool result = ::DdsJs::LongField::FromJsValueToCpp(jsVal, longVal);
	if (result)
	{
		cppValueRet = static_cast< %cpp_scoped_type_name(enumDef)%::ValueType >(longVal);
	}
	
	return result;
}

>>

struct_decl(structDef,options) ::= <<
// ======================================================
// TOPIC DECLARATION: %structDef.structName%
// ======================================================
struct %structDef.structName%Field
{
	typedef %cpp_scoped_name(structDef.owningModule,structDef.structName)% ValueType;
	typedef %cpp_scoped_name(structDef.owningModule,structDef.structName)%& RefType;
	typedef %cpp_scoped_name(structDef.owningModule,structDef.structName)% const& ConstRefType;
	typedef %cpp_scoped_name(structDef.owningModule,structDef.structName)% *PtrType;
	
	// Structure Field Names
	%structDef.fields:struct_field_name_decl()%
	
	// V8 Management Functions
	static void Init(::v8::Local< ::v8::Object > exports);
	static void New(::v8::FunctionCallbackInfo< ::v8::Value > const& args);
	static ::v8::Local< ::v8::Value > FromCppToJsValue(ConstRefType cppValue);
	static bool FromJsValueToCpp(::v8::Local< ::v8::Value > jsVal, RefType cppValueRet);
};

%if(options.generateTopicWrappers)%
// DDS Topic class wrap for %structDef.structName%
class %structDef.structName%TopicWrap : public ::node::ObjectWrap
{
public:
	static void Init(::v8::Local< ::v8::Object > exports);
	
private:
	%structDef.structName%TopicWrap();
	virtual ~%structDef.structName%TopicWrap();
	
	static ::v8::Persistent< ::v8::Function > constructor;
	
	static void New(::v8::FunctionCallbackInfo< ::v8::Value > const& args);
	static void NewDataWriter(::v8::FunctionCallbackInfo< ::v8::Value > const& args);
	static void NewDataReader(::v8::FunctionCallbackInfo< ::v8::Value > const& args);
	
	::DDS::Topic *m_theTopic;
};

// DDS Topic configuration class for %structDef.structName%
struct %structDef.structName%TopicConfig
{
	typedef %structDef.structName%DataReader ReaderType;
	typedef %structDef.structName%DataWriter WriterType;
	typedef %structDef.structName% TopicDataType;
	typedef %structDef.structName%PtrSeq TopicPtrSeqType;
	typedef %structDef.structName%Field TopicFieldClass;
	static const ::std::string TopicName;
};

// DDS DataReader wrap typedef for topic %structDef.structName%
typedef ::DdsJs::DataReaderWrap< %structDef.structName%TopicConfig > %structDef.structName%ReaderWrap;

// DDS DataWriter wrap typedef for topic %structDef.structName%
typedef ::DdsJs::DataWriterWrap< %structDef.structName%TopicConfig > %structDef.structName%WriterWrap;

%endif%
>>

struct_field_name_decl(fieldDef) ::= <<
static ::v8::Persistent< ::v8::String > %fieldDef.fieldName%FieldName;

>>

struct_impl(structDef,options) ::= <<
// ======================================================
// TOPIC IMPLEMENTATION: %structDef.structName%
// ======================================================
%struct_impl_field_names(structDef)%
%struct_impl_init(structDef)%
%struct_impl_new(structDef)%
%struct_impl_from_cpp(structDef)%
%struct_impl_from_js(structDef)%
%if(options.generateTopicWrappers)%
%impl_dds_topic_wrap_static_vars(structDef)%
%impl_dds_topic_config_static_vars(structDef)%
%impl_dds_topic_wrap_init(structDef)%
%impl_dds_topic_wrap_ctor_dtor(structDef)%
%impl_dds_topic_wrap_new(structDef)%
%impl_dds_topic_wrap_new_data_reader(structDef)%
%impl_dds_topic_wrap_new_data_writer(structDef)%
%endif%
>>

struct_impl_field_names(structDef) ::= <<
// Field names for topic %structDef.structName%
%structDef.fields:struct_impl_field_name(structDef)%
>>

struct_impl_field_name(structField,structDef) ::= <<
Persistent<String> %structDef.structName%Field::%structField.fieldName%FieldName;

>>

struct_impl_init(structDef) ::= <<
// Initialization of topic %structDef.structName% field type.
void %structDef.structName%Field::Init(Local<Object> exports)
{
	Isolate *isolate = Isolate::GetCurrent();
	Local< Context > ctx = isolate->GetCurrentContext();
	
	if (nullptr == isolate)
	{
		return;
	}

	auto ctorFuncTmpl = FunctionTemplate::New(
		isolate,
		%structDef.structName%Field::New
	);

	auto ctorFuncMaybe = ctorFuncTmpl->GetFunction(ctx);
	if (ctorFuncMaybe.IsEmpty())
	{
		// TODO: Throw exception
		return;
	}
	Maybe< bool > setResult = exports->Set(
		ctx,
		String::NewFromUtf8(isolate, "%structDef.structName%"),
		ctorFuncMaybe.ToLocalChecked()
	);
	if (setResult.IsNothing() || !setResult.FromJust())
	{
		// TODO: Throw exception
		return;
	}

	%structDef.fields:{ aField | %structDef.structName%Field::%aField.fieldName%FieldName.Reset(isolate,
	String::NewFromUtf8(isolate, "%aField.fieldName%"));
	}%
}

>>

struct_impl_new(structDef) ::= <<
// New instance of topic %structDef.structName% field type.
void %structDef.structName%Field::New(FunctionCallbackInfo<Value> const& args)
{
	Isolate *isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);
	
	args.GetReturnValue().Set(
		%structDef.structName%Field::FromCppToJsValue(
			%structDef.structName%Field::ValueType()));
}

>>

struct_impl_from_cpp(structDef) ::= <<
// From C++ to JavaScript for topic %structDef.structName%
Local<Value> %structDef.structName%Field::FromCppToJsValue(%structDef.structName%Field::ConstRefType cppValue)
{
	Isolate *isolate = Isolate::GetCurrent();
	EscapableHandleScope scope(isolate);
	Local<Object> result(Object::New(isolate));
	Local<Context> ctx = Local<Context>::New(isolate, isolate->GetCurrentContext());
	Maybe< bool > setResult = ::v8::Nothing< bool >();
	
	%structDef.fields:struct_impl_from_cpp_field(structDef)%
	
	return scope.Escape(result);
}

>>

struct_impl_from_cpp_field(structField,structDef) ::= <<
setResult = result->Set(
	ctx,
	Local<String>::New(
		isolate,
		%structDef.structName%Field::%structField.fieldName%FieldName
	),
	%cpp_scoped_type_name(structField.fieldType)%::FromCppToJsValue(
		cppValue.%structField.fieldName%
	)
);

if (!setResult.FromMaybe(false))
{
	// TODO: throw exception
}
>>

struct_impl_from_js(structDef) ::= <<
// From JavaScript to C++ for topic %structDef.structName%
bool %structDef.structName%Field::FromJsValueToCpp(Local<Value> jsVal, %structDef.structName%Field::RefType cppValueRet)
{
	Isolate *isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);
	Local<Context> ctx = Local<Context>::New(isolate, isolate->GetCurrentContext());
	MaybeLocal<Object> jsObjMaybe;
	bool result = true;
	MaybeLocal<Value> fieldMaybe;
	Local<Object> jsObject;
	%structDef.fields: { aField | Local<String> l_%aField.fieldName%FieldName =
	Local<String>::New(isolate,
		%structDef.structName%Field::%aField.fieldName%FieldName);
	}%
	
	result = !(jsObjMaybe = jsVal->ToObject(ctx)).IsEmpty() &&
		!(jsObject = jsObjMaybe.FromMaybe(Local<Object>())).IsEmpty();
	%structDef.fields:struct_impl_from_js_field()%
	
	return result;
}

>>

struct_impl_from_js_field(structField) ::= <<
result = result &&
	!(fieldMaybe = jsObject->Get(ctx, l_%structField.fieldName%FieldName)).IsEmpty() &&
	%cpp_scoped_type_name(structField.fieldType)%::FromJsValueToCpp(fieldMaybe.FromMaybe(Local<Value>()), cppValueRet.%structField.fieldName%);

>>

impl_dds_topic_wrap_static_vars(structDef) ::= <<
// Static variables for %structDef.structName% DDS topic wrap
Persistent<Function> %structDef.structName%TopicWrap::constructor;

>>

impl_dds_topic_config_static_vars(structDef) ::= <<
// Static variables for %structDef.structName% DDS topic configuration class
const string %structDef.structName%TopicConfig::TopicName = "%structDef.structName%";

>>

impl_dds_topic_wrap_init(structDef) ::= <<
// Implementation of Init() for %structDef.structName% DDS topic wrap
void %structDef.structName%TopicWrap::Init(Local<Object> exports)
{
	Isolate *isolate = Isolate::GetCurrent();
	Local<Context> ctx = Local<Context>::New(isolate, isolate->GetCurrentContext());
	HandleScope scope(isolate);
	
	// Constructor template
	Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, %structDef.structName%TopicWrap::New);
	tpl->SetClassName(String::NewFromUtf8(isolate, "%structDef.structName%Topic"));
	tpl->InstanceTemplate()->SetInternalFieldCount(2);
	
	// Object properties
	tpl->InstanceTemplate()->Set(isolate, "participant", Null(isolate));
	
	// Prototype
	NODE_SET_PROTOTYPE_METHOD(tpl, "newDataReader", %structDef.structName%TopicWrap::NewDataReader);
	NODE_SET_PROTOTYPE_METHOD(tpl, "newDataWriter", %structDef.structName%TopicWrap::NewDataWriter);
	
	%structDef.structName%TopicWrap::constructor.Reset(isolate, tpl->GetFunction());
	exports->Set(ctx, String::NewFromUtf8(isolate, "%structDef.structName%Topic"), tpl->GetFunction());
}

>>

impl_dds_topic_wrap_ctor_dtor(structDef) ::= <<
// Implementation of Constructor/Destructor for %structDef.structName% DDS topic wrap
%structDef.structName%TopicWrap::%structDef.structName%TopicWrap()
: m_theTopic(NULL)
{}

%structDef.structName%TopicWrap::~%structDef.structName%TopicWrap()
{ m_theTopic = NULL; }

>>

impl_dds_topic_wrap_new(structDef) ::= <<
// Implementation of New() for %structDef.structName% DDS topic wrap
void %structDef.structName%TopicWrap::New(FunctionCallbackInfo<Value> const& args)
{
	Isolate *isolate = Isolate::GetCurrent();
	Local<Context> ctx = Local<Context>::New(isolate, isolate->GetCurrentContext());
	HandleScope scope(isolate);
	ReturnCode_t ddsRetCode = DDS::RETCODE_OK;
	stringstream errorMsg;
	MaybeLocal<Object> participMaybe;
	Local<Object> particip;
	
	if (args.Length() < 1)
	{
		isolate->ThrowException(
			Exception::TypeError(
				String::NewFromUtf8(
					isolate,
					"%structDef.structName%Topic constructor called with too few arguments.")));
		return;
	}
	
	if ((participMaybe = args[0]->ToObject(ctx)).IsEmpty() ||
		((particip = participMaybe.FromMaybe(Local<Object>()))->InternalFieldCount() < 2) ||
		(particip->GetAlignedPointerFromInternalField(1) == NULL))
	{
		isolate->ThrowException(
			Exception::TypeError(
				String::NewFromUtf8(
					isolate,
					"Invalid participant object passed to %structDef.structName%Topic constructor.")));
		return;
	}
	
	if (args.IsConstructCall())
	{
		args.This()->Set(ctx, String::NewFromUtf8(isolate, "participant"), particip);
		DomainParticipant *theParticip = reinterpret_cast<DomainParticipant*>(particip->GetAlignedPointerFromInternalField(1));
		%structDef.structName%TypeSupport typeSupport;
		ddsRetCode = typeSupport.register_type(theParticip, NULL);
		if (ddsRetCode != DDS::RETCODE_OK)
		{
			errorMsg << "Could not register %structDef.structName% type:" << DDS_error(ddsRetCode);
			isolate->ThrowException(Exception::Error(String::NewFromUtf8(isolate, errorMsg.str().c_str())));
			return;
		}
		%structDef.structName%TopicWrap *obj = new %structDef.structName%TopicWrap();
		::DDS::TopicQos topicQos;
		theParticip->get_default_topic_qos(&topicQos);
		if ((args.Length() > 1) && !args[1]->IsNull())
		{
			if (!::DDS::TopicQosField::FromJsValueToCpp(args[1], topicQos))
			{
				isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "Invalid QoS object passed to Topic constructor.")));
				delete obj;
				obj = NULL;
				return;
			}
		}
		obj->m_theTopic = theParticip->create_topic("%structDef.structName%", typeSupport.get_type_name(), topicQos, NULL, 0);
		if (NULL == obj->m_theTopic)
		{
			isolate->ThrowException(Exception::Error(String::NewFromUtf8(isolate, "Could not create %structDef.structName% DDS topic object.")));
			delete obj;
			obj = NULL;
			return;
		}
		args.This()->SetAlignedPointerInInternalField(1, obj->m_theTopic);
		obj->Wrap(args.This());
		args.GetReturnValue().Set(args.This());
	}
	else
	{
		unsigned argc = 3u;
		Local<Value> argv[] = {
			args[0],
			Undefined(isolate),
			Undefined(isolate)
		};
		if (args.Length() > 2) argv[2] = args[2]; else argc--;
		if (args.Length() > 1) argv[1] = args[1]; else argc--;
		Local<Function> cons = Local<Function>::New(isolate, %structDef.structName%TopicWrap::constructor);
		MaybeLocal< Object > resultMaybe = cons->NewInstance(ctx, argc, argv);
		if (resultMaybe.IsEmpty())
		{
			isolate->ThrowException(Exception::Error(String::NewFromUtf8(isolate, "Could not create %structDef.structName% topic object.")));
			return;
		}
		args.GetReturnValue().Set(resultMaybe.FromMaybe(Local< Object >()));
	}
}

>>

impl_dds_topic_wrap_new_data_reader(structDef) ::= <<
// Implementation of NewDataReader() for %structDef.structName% DDS topic wrap
void %structDef.structName%TopicWrap::NewDataReader(FunctionCallbackInfo<Value> const& args)
{
	Isolate *isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);
	
	if (args.Length() < 1)
	{
		isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "%structDef.structName%.newDataReader() called with too few arguments.")));
		return;
	}
	
	unsigned argc = 4u;
	Local<Value> argv[] = {
		args[0],
		args.This(),
		Undefined(isolate),
		Undefined(isolate)
	};
	if (args.Length() > 2) argv[3] = args[2]; else argc--;
	if (args.Length() > 1) argv[2] = args[1]; else argc--;
	
	Local<Function> rdrCons = Local<Function>::New(isolate, %structDef.structName%ReaderWrap::constructor);
	MaybeLocal< Object > resultMaybe = rdrCons->NewInstance(isolate->GetCurrentContext(), argc, argv);
	if (resultMaybe.IsEmpty())
	{
		isolate->ThrowException(Exception::Error(String::NewFromUtf8(isolate, "Could not create DataReader for %structDef.structName% topic.")));
		return;
	}
	args.GetReturnValue().Set(resultMaybe.FromMaybe(Local< Object >()));
}

>>

impl_dds_topic_wrap_new_data_writer(structDef) ::= <<
// Implementation of NewDataWriter() for %structDef.structName% DDS topic wrap
void %structDef.structName%TopicWrap::NewDataWriter(FunctionCallbackInfo<Value> const& args)
{
	Isolate *isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);
	
	if (args.Length() < 1)
	{
		isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "%structDef.structName%.newDataWriter() called with too few arguments.")));
		return;
	}
	
	unsigned argc = 4u;
	Local<Value> argv[] = {
		args[0],
		args.This(),
		Undefined(isolate),
		Undefined(isolate)
	};
	if (args.Length() > 2) argv[3] = args[2]; else argc--;
	if (args.Length() > 1) argv[2] = args[1]; else argc--;
	
	Local<Function> wrtCons = Local<Function>::New(isolate, %structDef.structName%WriterWrap::constructor);
	MaybeLocal< Object > resultMaybe = wrtCons->NewInstance(isolate->GetCurrentContext(), argc, argv);
	if (resultMaybe.IsEmpty())
	{
		isolate->ThrowException(Exception::Error(String::NewFromUtf8(isolate, "Could not create DataWriter for %structDef.structName% topic.")));
		return;
	}
	args.GetReturnValue().Set(resultMaybe.FromMaybe(Local< Object >()));
}

>>

struct_init(structDef,options) ::= <<
%cpp_scoped_name(structDef.owningModule, structDef.structName)%Field::Init(moduleExports);
%if(options.generateTopicWrappers)%
%["TopicWrap","ReaderWrap","WriterWrap"]:{ suffix | %cpp_scoped_name(structDef.owningModule, structDef.structName)%%suffix%::Init(moduleExports);
}%
%endif%
>>

union_decl(unionDef) ::= <<
// ======================================================
// UNION DECLARATION: %unionDef.unionName%
// ======================================================
struct %unionDef.unionName%Field
{
	typedef %cpp_scoped_name(unionDef.owningModule,unionDef.unionName)% ValueType;
	typedef %cpp_scoped_name(unionDef.owningModule,unionDef.unionName)%& RefType;
	typedef %cpp_scoped_name(unionDef.owningModule,unionDef.unionName)% const& ConstRefType;
	typedef %cpp_scoped_name(unionDef.owningModule,unionDef.unionName)% *PtrType;
	
	%unionDef.unionCases:union_case_name_decl()%
	
	static void Init(::v8::Local< ::v8::Object > exports);
	static void New(::v8::FunctionCallbackInfo< ::v8::Value > const& args);
	static ::v8::Local< ::v8::Value > FromCppToJsValue(ConstRefType cppValue);
	static bool FromJsValueToCpp(::v8::Local< ::v8::Value > jsVal, RefType cppValueRet);
};

>>

union_case_name_decl(unionCase) ::= <<
%unionCase.caseMembers:{ aMember | static ::v8::Persistent< ::v8::String > %aMember.fieldName%FieldName; }%

>>

union_impl(unionDef) ::= <<
// ======================================================
// UNION IMPLEMENTATION
// ======================================================
%unionDef.unionCases:union_impl_case_member_names(unionDef)%

%union_impl_field_init(unionDef)%
%union_impl_field_new(unionDef)%
%union_impl_field_from_cpp(unionDef)%
%union_impl_field_from_js(unionDef)%
>>

union_impl_case_member_names(unionCase,unionDef) ::= <<
%unionCase.caseMembers:{ aMember | Persistent<String> %unionDef.unionName%Field::%aMember.fieldName%FieldName;}%

>>

union_impl_field_init(unionDef) ::= <<
// Implementation of Init() for union %unionDef.unionName% field type.
void %unionDef.unionName%Field::Init(Local<Object> exports)
{
	Isolate *isolate = Isolate::GetCurrent();
	exports->Set(isolate->GetCurrentContext(),
		String::NewFromUtf8(isolate, "%unionDef.unionName%"),
		FunctionTemplate::New(isolate, %unionDef.unionName%Field::New)->GetFunction());
	%unionDef.unionCases:union_impl_case_members(unionDef)%
}

>>

union_impl_case_members(unionCase,unionDef) ::= <<
%unionCase.caseMembers:{ aMember | %unionDef.unionName%Field::%aMember.fieldName%FieldName.Reset(isolate,
	String::NewFromUtf8(isolate, "%aMember.fieldName%")); }%

>>

union_impl_field_new(unionDef) ::= <<
// Implementation of New() for union %unionDef.unionName% field type.
void %unionDef.unionName%Field::New(FunctionCallbackInfo<Value> const& args)
{
	Isolate *isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);
	
	args.GetReturnValue().Set(%unionDef.unionName%Field::FromCppToJsValue(%unionDef.unionName%Field::ValueType()));
}

>>

union_impl_field_from_cpp(unionDef) ::= <<
// From C++ to JavaScript for union %unionDef.unionName%
Local<Value> %unionDef.unionName%Field::FromCppToJsValue(%unionDef.unionName%Field::ConstRefType cppValue)
{
	Isolate *isolate = Isolate::GetCurrent();
	Local<Context> ctx = Local<Context>::New(isolate, isolate->GetCurrentContext());
	EscapableHandleScope scope(isolate);
	Local<Object> result(Object::New(isolate));
	
	switch(cppValue.discriminator())
	{
	%unionDef.unionCases:union_impl_field_from_cpp_case(unionDef)%
	}
	
	return scope.Escape(result);
}

>>

union_impl_field_from_cpp_case(unionCase,unionDef) ::= <<
case %cpp_scoped_name(unionDef.owningModule,unionCase.caseLabel)%:
	%unionCase.caseMembers:{ aMember | result->Set(ctx, Local<String>::New(isolate, %unionDef.unionName%Field::%aMember.fieldName%FieldName),
	%cpp_scoped_type_name(aMember.fieldType)%::FromCppToJsValue(cppValue.%aMember.fieldName%())); }%
	break;

>>

union_impl_field_from_js(unionDef) ::= <<
// From JavaScript to C++ for union %unionDef.unionName%
bool %unionDef.unionName%Field::FromJsValueToCpp(Local<Value> jsVal, %unionDef.unionName%Field::RefType cppValueRet)
{
	Isolate *isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);
	Local<Context> ctx = Local<Context>::New(isolate, isolate->GetCurrentContext());
	MaybeLocal<Object> jsObjMaybe;
	Local<Object> jsObject;
	MaybeLocal<Value> fieldMaybe;
	Local<Value> fieldValue;
	bool valueFound = false;
	
	jsObjMaybe = jsVal->ToObject(ctx);
	if (jsObjMaybe.IsEmpty())
	{
		return false;
	}
	
	jsObject = jsObjMaybe.FromMaybe(Local<Object>());
	%unionDef.unionCases:union_impl_field_from_js_case(unionDef)%
	
	return valueFound;
}

>>

union_impl_field_from_js_case(unionCase,unionDef) ::= <<
%unionCase.caseMembers:union_impl_field_from_js_case_memb(unionDef)%
>>

union_impl_field_from_js_case_memb(caseMember,unionDef) ::= <<
if (!valueFound &&
	!(fieldMaybe = jsObject->Get(ctx, Local<String>::New(isolate, %unionDef.unionName%Field::%caseMember.fieldName%FieldName))).IsEmpty())
{
	%cpp_scoped_type_name(caseMember.fieldType)%::ValueType caseVal;
	fieldValue = fieldMaybe.FromMaybe(Local<Value>());
	if (%cpp_scoped_type_name(caseMember.fieldType)%::FromJsValueToCpp(fieldValue, caseVal))
	{
		cppValueRet.%caseMember.fieldName%(caseVal);
		valueFound = true;
	}
}

>>

cpp_scoped_name(module,typeName) ::= "%module_hierarchy(module)%::%typeName%"

cpp_scoped_type_name(typeObj) ::= "%({cpp_scoped_type_name_%typeObj.idlTypeClass%})(typeObj)%"

cpp_scoped_type_name_array(arrayType) ::= "::DdsJs::ArrayField< %cpp_scoped_type_name(arrayType.elementType)%, %arrayType.arraySize% >"

cpp_scoped_type_name_boolean(primitiveType) ::= "::DdsJs::BooleanField"

cpp_scoped_type_name_enum(enumType) ::= "%cpp_scoped_name(enumType.owningModule,enumType.enumName)%Field"

cpp_scoped_type_name_double(primitiveType) ::= "::DdsJs::DoubleField"

cpp_scoped_type_name_float(primitiveType) ::= "::DdsJs::FloatField"

cpp_scoped_type_name_long(primitiveType) ::= "::DdsJs::LongField"

cpp_scoped_type_name_octet(primitiveType) ::= "::DdsJs::OctetField"

cpp_scoped_type_name_sequence(sequenceType) ::= <%
%if(sequenceType.sequenceBoundsDefined)%
::DdsJs::FixedSequenceField< %cpp_scoped_type_name(sequenceType.elementType)%, %sequenceType.sequenceBounds% >
%else%
::DdsJs::UnboundedSeqField< %cpp_scoped_type_name(sequenceType.elementType)% >
%endif%
%>

cpp_scoped_type_name_short(primitiveType) ::= "::DdsJs::ShortField"

cpp_scoped_type_name_string(stringType) ::= <%
%if(stringType.maxLengthDefined)%
::DdsJs::FixedStringField< %stringType.maxLength% >
%else%
::DdsJs::UnboundedStringField
%endif%
%>

cpp_scoped_type_name_struct(structType) ::= "%cpp_scoped_name(structType.owningModule,structType.structName)%Field"

cpp_scoped_type_name_union(unionType) ::= "%cpp_scoped_name(unionType.owningModule,unionType.unionName)%Field"

cpp_scoped_type_name_unsigned_long(primitiveType) ::= "::DdsJs::UnsignedLongField"

cpp_scoped_type_name_unsigned_short(primitiveType) ::= "::DdsJs::UnsignedShortField"

module_hierarchy(module) ::= "%if(module)%%module_hierarchy(module.parentModule)%::%module.moduleName%%endif%"
