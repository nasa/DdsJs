/**
 * @file IdlParserListener.java
 * @brief Contains the class used to listen to parser events and errors.
 * @date 2014-08-10
 * @author Rolando J. Nieves
 */
package gov.nasa.ksc.ddsjs.idlc;

import java.io.File;
import java.util.BitSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Stack;

import org.antlr.v4.runtime.ANTLRErrorListener;
import org.antlr.v4.runtime.ANTLRFileStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.atn.ATNConfigSet;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.misc.NotNull;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import gov.nasa.ksc.ddsjs.model.IdlArrayType;
import gov.nasa.ksc.ddsjs.model.IdlEnumDefinition;
import gov.nasa.ksc.ddsjs.model.IdlModuleDefinition;
import gov.nasa.ksc.ddsjs.model.IdlPrimitiveType;
import gov.nasa.ksc.ddsjs.model.IdlSequenceType;
import gov.nasa.ksc.ddsjs.model.IdlStringType;
import gov.nasa.ksc.ddsjs.model.IdlStructFieldReceiver;
import gov.nasa.ksc.ddsjs.model.IdlStructureDefinition;
import gov.nasa.ksc.ddsjs.model.IdlStructureField;
import gov.nasa.ksc.ddsjs.model.IdlTypeAlias;
import gov.nasa.ksc.ddsjs.model.IdlTypeDefReceiver;
import gov.nasa.ksc.ddsjs.model.IdlConstantExpression;
import gov.nasa.ksc.ddsjs.model.IdlUnionCase;
import gov.nasa.ksc.ddsjs.model.IdlUnionDefinition;
import gov.nasa.ksc.ddsjs.model.IdlSizeDefReceiver;
import gov.nasa.ksc.ddsjs.parser.DdsJsIdlBaseListener;
import gov.nasa.ksc.ddsjs.parser.DdsJsIdlLexer;
import gov.nasa.ksc.ddsjs.parser.DdsJsIdlParser;

/**
 * Class that listens to all of the events generated by the DDS-to-Node.js IDL compiler.
 * 
 * The @c IdlParserListener class derives from the listener class generated by
 * the ANTLR 4 compiler-compiler after processing the @c DdsJsIdl.g4 grammar
 * description. The parser generated by ANTLR emits events every time it 
 * encounters a grammar "production," letting our custom code react to these
 * productions as appropriate. This implementation uses those events to 
 * instantiate an object model that represents the contents of an IDL file in
 * an easily traversable form.
 *
 * In general, the pattern implemented in this listener is the inclusion of two
 * methods for every grammar production we're interested in. One of the two methods
 * is called when the production is first encountered (identified by the \c enter 
 * prefix in the name). The other method is called when the parser is done with
 * the grammar production (identified by the \c exit prefix in the name). It should
 * be noted that not all grammar production require both an \c enter and \c exit
 * listener method.
 *
 * In addition, since types have to be narrowed down to their basic building blocks,
 * the \c typedef constructs in the IDL file are completely resolved in this
 * compilation stage. Thus, the \c typedef alias name provided in the IDL file does
 * not make it to the resulting object tree.
 * 
 * The class upon which this class is based is generated by the ANTLR grammar compiler.
 */
public class IdlParserListener extends DdsJsIdlBaseListener implements ANTLRErrorListener {

	private IdlEnumDefinition currentEnum;
	private IdlUnionDefinition currentUnion;
	private IdlStructFieldReceiver currentFieldReceiver;
	private IdlSizeDefReceiver sizeDefReceiver;
	private Stack<IdlTypeDefReceiver> typedefStack;
	private Map<String, IdlModuleDefinition> rootModuleMap;
	private Stack<IdlModuleDefinition> moduleStack;
	private IdlModuleDefinition scopedNameSearchBase;
	private int semanticErrorCount;
	private Stack<String> fileNameStack;
	private IdlModuleDefinition scopedNameModule;
	private String[] includePath;
	
	public IdlParserListener(String initialFileName, String[] includePath) {
		this.typedefStack = new Stack<IdlTypeDefReceiver>();
		this.rootModuleMap = new HashMap<String, IdlModuleDefinition>();
		this.moduleStack = new Stack<IdlModuleDefinition>();
		this.fileNameStack = new Stack<String>();
		this.fileNameStack.push(initialFileName);
		this.includePath = includePath;
	}
	
	protected int getSemanticErrorCount() {
		return this.semanticErrorCount;
	}
	
	public Map<String, IdlModuleDefinition> getResult() {
		return this.rootModuleMap;
	}
	
	protected String includeFileToIncludePath(String includeFileName) {
		String result = includeFileName;
		
		if (this.includePath != null) {
			for (String aPath : this.includePath) {
				File includeFile = new File(aPath, includeFileName);
				if (includeFile.exists()) {
					result = includeFile.getAbsolutePath();
				}
			}
		}
		return result;
	}
	
	@Override public void enterIncludeCompilerDirective(@NotNull DdsJsIdlParser.IncludeCompilerDirectiveContext ctx) {
		String includeFileName = ctx.INCLUDE_FILESPEC().getText();
		includeFileName = includeFileName.substring(1, includeFileName.length() - 2);
		String includeFilePath = this.includeFileToIncludePath(includeFileName);
		this.fileNameStack.push(includeFilePath);
		try {
			// ----------------------------------------------------------------
			// When an include file is encountered, save the name of the 
			// current file being processed, and process the included file 
			// right away.
			// ----------------------------------------------------------------
			ANTLRFileStream input = new ANTLRFileStream(includeFilePath);
			DdsJsIdlLexer lexer = new DdsJsIdlLexer(input);
			lexer.removeErrorListeners();
			lexer.addErrorListener(this);
			CommonTokenStream tokens = new CommonTokenStream(lexer);
			DdsJsIdlParser parser = new DdsJsIdlParser(tokens);
			parser.removeErrorListeners();
			parser.addErrorListener(this);
			ParseTree tree = parser.translationUnit();
			ParseTreeWalker walker = new ParseTreeWalker();
			
			walker.walk(this, tree);
		} catch (java.io.IOException ex) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Could not include file \"" + includeFileName + "\":" + ex.getMessage());
		}
	}
	
	@Override public void exitIncludeCompilerDirective(@NotNull DdsJsIdlParser.IncludeCompilerDirectiveContext ctx) {
		this.fileNameStack.pop();
	}
	
	@Override public void enterModule(@NotNull DdsJsIdlParser.ModuleContext ctx) {
		IdlModuleDefinition moduleToOpen = null;
		IdlModuleDefinition parentModule = null;
		
		// --------------------------------------------------------------------
		// Since modules can contain other modules, we must model their
		// acquisition using a stack.
		// --------------------------------------------------------------------
		if (this.moduleStack.empty()) {
			moduleToOpen = this.rootModuleMap.get(ctx.IDENTIFIER().getText());
		} else {
			parentModule = this.moduleStack.peek();
			moduleToOpen = parentModule.resolveModuleName(ctx.IDENTIFIER().getText(), /*children only*/true);
		}
		
		if (moduleToOpen == null) {
			moduleToOpen = new IdlModuleDefinition(ctx.IDENTIFIER().getText(), parentModule);
		}
		
		this.moduleStack.push(moduleToOpen);
	}
	
	@Override public void exitModule(@NotNull DdsJsIdlParser.ModuleContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Module stack underflow when closing out a module.");
		} else {
			IdlModuleDefinition closingModule = this.moduleStack.pop();
			if (this.moduleStack.empty()) {
				this.rootModuleMap.put(closingModule.getModuleName(), closingModule);
			} else {
				this.moduleStack.peek().registerChildModule(closingModule);
			}
		}
	}
	
	@Override public void enterManualNumbered(@NotNull DdsJsIdlParser.ManualNumberedContext ctx) {
		if (this.currentEnum == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Manual-numbered enum constant outside enum definition.");
		} else {
			this.currentEnum.addEnumConstant(ctx.IDENTIFIER().getText(), this.integerValueContextToValue(ctx.integerValue()));
		}
	}
	
	@Override public void enterAutoNumbered(@NotNull DdsJsIdlParser.AutoNumberedContext ctx) {
		if (this.currentEnum == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Auto-numbered enum constant outside enum definition.");
		} else {
			this.currentEnum.addEnumConstant(ctx.IDENTIFIER().getText(), this.currentEnum.nextAutoNumbered());
		}
	}
	
	@Override public void enterEnumDefinition(@NotNull DdsJsIdlParser.EnumDefinitionContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Module stack underflow while starting enumerated type definition.");
		}
		else if (this.currentEnum != null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Definition of an enumerated type inside of another enumerated type.");
		} else {
			this.currentEnum = new IdlEnumDefinition(ctx.IDENTIFIER().getText(), this.moduleStack.peek());
		}
	}
	
	@Override public void exitEnumDefinition(@NotNull DdsJsIdlParser.EnumDefinitionContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Module stack underflow while closing out enum definition.");
		} else if (this.currentEnum == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Closing out enum definition when none had been started.");
		} else {
			this.moduleStack.peek().addEnumDefinition(this.currentEnum);
			this.currentEnum = null;
		}
	}
	
	@Override public void enterNonArrayTypedef(@NotNull DdsJsIdlParser.NonArrayTypedefContext ctx) {
		if (!this.typedefStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Non-array type definition started while another type definition had not been closed out.");
		} else {
			IdlTypeAlias typeAlias = new IdlTypeAlias(ctx.IDENTIFIER().getText(), null);
			this.typedefStack.push(typeAlias);
		}
	}
	
	@Override public void exitNonArrayTypedef(@NotNull DdsJsIdlParser.NonArrayTypedefContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Module stack underflow while closing out non-array type alias.");
		} else if (this.typedefStack.empty() || !(this.typedefStack.peek() instanceof IdlTypeAlias)) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent type definition stack state while closing out non-array type alias.");
		} else {
			IdlTypeAlias typeAlias = (IdlTypeAlias)this.typedefStack.pop();
			this.moduleStack.peek().addTypeAlias(typeAlias);
		}
	}
	
	@Override public void enterArrayTypedef(@NotNull DdsJsIdlParser.ArrayTypedefContext ctx) {
		if (!this.typedefStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Array type definition started while another type definition had not been closed out.");
		} else {
			IdlArrayType arrayType = new IdlArrayType(null, Integer.parseInt(ctx.DECIMAL_VALUE().getText()));
			IdlTypeAlias typeAlias = new IdlTypeAlias(ctx.IDENTIFIER().getText(), arrayType);
			this.typedefStack.push(typeAlias);
			this.typedefStack.push(arrayType);
		}
	}
	
	@Override public void exitArrayTypedef(@NotNull DdsJsIdlParser.ArrayTypedefContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Module stack underflow while closing out array type alias.");
		} else if ((this.typedefStack.size() < 2) || !(this.typedefStack.peek() instanceof IdlArrayType)) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent type definition stack state while closing out array type alias.");
		} else {
			this.typedefStack.pop(); // Pop the array type definition that's already inside the type alias.
			IdlTypeAlias typeAlias = (IdlTypeAlias)this.typedefStack.pop();
			this.moduleStack.peek().addTypeAlias(typeAlias);
		}
	}
	
	@Override public void enterIntTypeDescription(@NotNull DdsJsIdlParser.IntTypeDescriptionContext ctx) {
		if (this.typedefStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Type definition stack underflow while starting integer type description.");
		} else {
			Object result = null;
			
			if (ctx.OCTET_KW() != null) {
				result = new IdlPrimitiveType(IdlPrimitiveType.Primitive.OCTET);
			} else if (ctx.SHORT_KW() != null) {
				if (ctx.UNSIGNED_KW() != null) {
					result = new IdlPrimitiveType(IdlPrimitiveType.Primitive.USHORT);
				} else {
					result = new IdlPrimitiveType(IdlPrimitiveType.Primitive.SHORT);
				}
			} else if (ctx.LONG_KW() != null) {
				if (ctx.UNSIGNED_KW() != null) {
					result = new IdlPrimitiveType(IdlPrimitiveType.Primitive.ULONG);
				} else {
					result = new IdlPrimitiveType(IdlPrimitiveType.Primitive.LONG);
				}
			} else {
				this.printErrorMessage(
						ctx.getStart().getLine(),
						ctx.getStart().getCharPositionInLine(),
						"Unknown integer type \"" + ctx.getText() + "\".");
			}
			
			try {
				this.typedefStack.peek().setTypeDefinition(result);
			} catch (RuntimeException ex) {
				this.printErrorMessage(
						ctx.getStart().getLine(),
						ctx.getStart().getCharPositionInLine(),
						ex.getMessage());
			}
		}
	}
	
	@Override public void enterFloatTypeDescription(@NotNull DdsJsIdlParser.FloatTypeDescriptionContext ctx) {
		if (this.typedefStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Type definition stack underflow while starting floating point type description.");
		} else {
			Object result = null;
			
			if (ctx.FLOAT_KW() != null) {
				result = new IdlPrimitiveType(IdlPrimitiveType.Primitive.FLOAT);
			} else if (ctx.DOUBLE_KW() != null) {
				result = new IdlPrimitiveType(IdlPrimitiveType.Primitive.DOUBLE);
			} else {
				this.printErrorMessage(
						ctx.getStart().getLine(),
						ctx.getStart().getCharPositionInLine(),
						"Unknown floating point type \"" + ctx.getText() + "\".");
			}
			
			try {
				this.typedefStack.peek().setTypeDefinition(result);
			} catch (RuntimeException ex) {
				this.printErrorMessage(
						ctx.getStart().getLine(),
						ctx.getStart().getCharPositionInLine(),
						ex.getMessage());
			}
		}
	}
	
	@Override public void enterSequenceTypeDescription(@NotNull DdsJsIdlParser.SequenceTypeDescriptionContext ctx) {
		IdlSequenceType seqType;
		
		if (this.typedefStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Type definition stack underflow while starting sequence type description.");
		} else {
			seqType = new IdlSequenceType(null);
			
			try {
				this.typedefStack.peek().setTypeDefinition(seqType);
			} catch (RuntimeException ex) {
				this.printErrorMessage(
						ctx.getStart().getLine(),
						ctx.getStart().getCharPositionInLine(),
						ex.getMessage());
			}
			this.typedefStack.push(seqType);
			this.sizeDefReceiver = (IdlSizeDefReceiver)seqType;
		}
	}

	@Override public void exitSequenceTypeDescription(@NotNull DdsJsIdlParser.SequenceTypeDescriptionContext ctx) {
		if (this.typedefStack.empty() || !(this.typedefStack.peek() instanceof IdlSequenceType)) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent type definition stack state while closing out sequence type description.");
		} else {
			this.typedefStack.pop();
			this.sizeDefReceiver = null;
		}
	}
	
	@Override public void enterStringTypeDescription(@NotNull DdsJsIdlParser.StringTypeDescriptionContext ctx) {
		if (this.typedefStack.size() == 0) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Type definition stack underflow while starting string type description.");
		} else {
			IdlStringType result = new IdlStringType();
			
			try {
				this.typedefStack.peek().setTypeDefinition(result);
			} catch (RuntimeException ex) {
				this.printErrorMessage(
						ctx.getStart().getLine(),
						ctx.getStart().getCharPositionInLine(),
						ex.getMessage());
			}
			this.sizeDefReceiver = result;
		}
	}
	
	@Override public void exitStringTypeDescription(@NotNull DdsJsIdlParser.StringTypeDescriptionContext ctx) {
		if (!(this.sizeDefReceiver instanceof IdlStringType)) {
			this.printErrorMessage(
				ctx.getStart().getLine(),
				ctx.getStart().getCharPositionInLine(),
				"Internal error: Inconsistent size definition receiver state while closing out string type description.");
		} else {
			this.sizeDefReceiver = null;
		}
	}

	@Override public void exitSizeAsConstantDefinition(@NotNull DdsJsIdlParser.SizeAsConstantDefinitionContext ctx) {
		if (this.sizeDefReceiver == null) {
			this.printErrorMessage(
				ctx.getStart().getLine(),
				ctx.getStart().getCharPositionInLine(),
				"Internal error: Expecting size definition receiver in parser but have none."
			);
		} else {
			String constantName = ctx.scopedName().getStop().getText();
			IdlConstantExpression theConst = this.scopedNameModule.resolveConstantName(constantName);
			if (theConst == null) {
				this.printErrorMessage(
						ctx.getStart().getLine(), 
						ctx.getStart().getCharPositionInLine(), 
						"Unknown constant \"" + constantName + "\".");
			} else if (!(theConst.getConstantValue() instanceof Long)) {
				this.printErrorMessage(
						ctx.getStart().getLine(), 
						ctx.getStart().getCharPositionInLine(), 
						"Constant used for size definition must be an integer.");
			} else {
				this.sizeDefReceiver.setSizeDefinition(theConst);
			}
			this.scopedNameModule = null;
		}
	}

	@Override public void exitSizeAsLiteralValue(@NotNull DdsJsIdlParser.SizeAsLiteralValueContext ctx) {
		if (this.sizeDefReceiver == null) {
			this.printErrorMessage(
				ctx.getStart().getLine(),
				ctx.getStart().getCharPositionInLine(),
				"Internal error: Expecting size definition receiver in parser but have none."
			);
		} else {
			this.sizeDefReceiver.setSizeDefinition(Integer.parseInt(ctx.DECIMAL_VALUE().getText()));
		}
	}

	@Override public void exitCustomTypeDescription(@NotNull DdsJsIdlParser.CustomTypeDescriptionContext ctx) {
		if (this.scopedNameModule == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: No scoped name module available for custom type description.");
		} else if (this.typedefStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Type definition receiver stack underflow at start of custom type name description.");
		} else {
			String typeName = ctx.scopedName().getStop().getText();
			Object typeObj = this.scopedNameModule.resolveTypeName(typeName);
			if (typeObj == null) {
				this.printErrorMessage(
						ctx.getStart().getLine(),
						ctx.getStart().getCharPositionInLine(),
						"Unknown type name \"" + typeName + "\".");
			} else try {
				this.typedefStack.peek().setTypeDefinition(typeObj);
			} catch (RuntimeException ex) {
				this.printErrorMessage(
						ctx.getStart().getLine(),
						ctx.getStart().getCharPositionInLine(),
						ex.getMessage());
			}
			
			this.scopedNameModule = null;
		}
	}
	
	@Override public void enterRelativeScopedName(@NotNull DdsJsIdlParser.RelativeScopedNameContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Module stack underflow at start of relative scoped name.");
		} else {
			IdlModuleDefinition destModule;
			int idIdx = 0;
			
			if (this.scopedNameSearchBase != null) {
				destModule = this.scopedNameSearchBase;
			} else {
				destModule = this.moduleStack.peek();
			}
			
			for (idIdx = 0; (idIdx < ctx.IDENTIFIER().size() - 1) && (destModule != null); idIdx++) {
				destModule = destModule.resolveModuleName(ctx.IDENTIFIER(idIdx).getText(), /* children and parent */false);
			}
			
			if (destModule == null) {
				this.printErrorMessage(
						ctx.getStart().getLine(), 
						ctx.getStart().getCharPositionInLine(), 
						"Unknown module \"" + ctx.IDENTIFIER(idIdx) + "\".");
			} else {
				this.scopedNameModule = destModule;
			}
			
			this.scopedNameSearchBase = null;
		}
	}
	
	@Override public void enterAbsoluteScopedName(@NotNull DdsJsIdlParser.AbsoluteScopedNameContext ctx) {
		this.scopedNameSearchBase = this.rootModuleMap.get(ctx.IDENTIFIER().getText());
		if (this.scopedNameSearchBase == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Unknown root-level module \"" + ctx.IDENTIFIER().getText() + "\".");
		}
	}
	
	@Override public void enterConstantDefinition(@NotNull DdsJsIdlParser.ConstantDefinitionContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Module stack underflow while starting out constant definition.");
		} else {
			IdlConstantExpression constExpr = new IdlConstantExpression(null, ctx.IDENTIFIER().getText(), null, this.moduleStack.peek());
			this.typedefStack.push(constExpr);
		}
	}
	
	@Override public void enterConstantValue(@NotNull DdsJsIdlParser.ConstantValueContext ctx) {
		if (this.typedefStack.empty() || !(this.typedefStack.peek() instanceof IdlConstantExpression)) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent type definition stack state when starting integer expression.");
		} else {
			IdlConstantExpression constExpr = (IdlConstantExpression)this.typedefStack.peek();
			if (ctx.integerValue() != null) {
				constExpr.setConstantValue(this.integerValueContextToValue(ctx.integerValue()));
			} else if (ctx.FLOAT_VALUE() != null) {
				constExpr.setConstantValue(java.lang.Double.parseDouble(ctx.FLOAT_VALUE().getText()));
			} else if (ctx.STRING_VALUE() != null) {
				constExpr.setConstantValue(ctx.STRING_VALUE());
			} else if (ctx.BOOLEAN_VALUE() != null) {
				constExpr.setConstantValue(java.lang.Boolean.parseBoolean(ctx.BOOLEAN_VALUE().getText()));
			}
		}
	}
	
	@Override public void exitConstantDefinition(@NotNull DdsJsIdlParser.ConstantDefinitionContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Module stack underflow while closing out constant definition.");
		} else if (this.typedefStack.empty() || !(this.typedefStack.peek() instanceof IdlConstantExpression)) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent type definition stack state while closing out constant definition.");
		} else {
			IdlConstantExpression constExpr = (IdlConstantExpression)this.typedefStack.pop();
			this.moduleStack.peek().addConstantDefinition(constExpr);
		}
	}
	
	@Override public void enterDataStructureDefinition(@NotNull DdsJsIdlParser.DataStructureDefinitionContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Module stack underflow while starting data structure definition.");
		} else if (this.currentFieldReceiver != null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Structure definitions embedded in other structure definitions is not supported at this time.");
		} else {
			this.currentFieldReceiver = new IdlStructureDefinition(ctx.IDENTIFIER().getText(), this.moduleStack.peek());
		}
	}
	
	@Override public void exitDataStructureDefinition(@NotNull DdsJsIdlParser.DataStructureDefinitionContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Module stack underflow while closing out data structure definition.");
		} else if ((this.currentFieldReceiver == null) || !(this.currentFieldReceiver instanceof IdlStructureDefinition)) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent field receiver state while closing out data structure definition.");
		} else {
			this.moduleStack.peek().addTopicDefinition((IdlStructureDefinition)this.currentFieldReceiver);
			this.currentFieldReceiver = null;
		}
	}
	
	@Override public void enterNonArrayMemberDefinition(@NotNull DdsJsIdlParser.NonArrayMemberDefinitionContext ctx) {
		if (this.currentFieldReceiver == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent field receiver state while starting a non-array member definition.");
		} else {
			IdlStructureField aField = new IdlStructureField(null, ctx.IDENTIFIER().getText());
			this.typedefStack.push(aField);
		}
	}
	
	@Override public void exitNonArrayMemberDefinition(@NotNull DdsJsIdlParser.NonArrayMemberDefinitionContext ctx) {
		if (this.currentFieldReceiver == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent field receiver state while closing out a non-array member definition.");
		} else if (this.typedefStack.size() == 0 || !(this.typedefStack.peek() instanceof IdlStructureField)) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Inconsistent type definition receiver stack state while closing out a non-array member definition.");
		} else {
			IdlStructureField aField = (IdlStructureField)this.typedefStack.pop();
			this.currentFieldReceiver.addStructureField(aField);
		}
	}
	
	@Override public void enterArrayMemberDefinition(@NotNull DdsJsIdlParser.ArrayMemberDefinitionContext ctx) {
		if (this.currentFieldReceiver == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent field receiver state while starting an array member definition.");
		} else {
			IdlArrayType arrayType = new IdlArrayType(null, Integer.parseInt(ctx.DECIMAL_VALUE().getText()));
			IdlStructureField aField = new IdlStructureField(arrayType, ctx.IDENTIFIER().getText());
			this.typedefStack.push(aField);
			this.typedefStack.push(arrayType);
		}
	}
	
	@Override public void exitArrayMemberDefinition(@NotNull DdsJsIdlParser.ArrayMemberDefinitionContext ctx) {
		if (this.currentFieldReceiver == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent field receiver state while closing out an array member definition.");
		} else if (this.typedefStack.size() < 2 || !(this.typedefStack.peek() instanceof IdlArrayType)) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Inconsistent type definition receiver stack state while closing out a non-array member definition.");
		} else {
			this.typedefStack.pop(); // Popping the array type that was already stored in the topic member.
			IdlStructureField aField = (IdlStructureField)this.typedefStack.pop();
			this.currentFieldReceiver.addStructureField(aField);
		}
	}
	
	@Override public void enterConstDimArrayMemberDefinition(@NotNull DdsJsIdlParser.ConstDimArrayMemberDefinitionContext ctx) {
		if (this.currentFieldReceiver == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent field receiver state while starting an array member definition.");
		} else {
			// ----------------------------------------------------------------
			// Since arrays can be embedded as "element types" into other arrays,
			// interpreting array type definitions require a pseudo-recursive
			// approach using a type definition stack.
            // Note: Embedding arrays as elements in other arrays is not 
            // exactly the same as a multi-dimensional array.
			// ----------------------------------------------------------------
			IdlArrayType arrayType = new IdlArrayType(null, 0);
			IdlStructureField aField = new IdlStructureField(arrayType, ctx.IDENTIFIER().getText());
			this.typedefStack.push(aField);
			this.typedefStack.push(arrayType);
		}
	}
	
	@Override public void exitConstDimArrayMemberDefinition(@NotNull DdsJsIdlParser.ConstDimArrayMemberDefinitionContext ctx) {
		if (this.currentFieldReceiver == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Closing out an array member definition with a constant symbol dimension without a receiving structure or union.");
		} else if (this.scopedNameModule == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent state for the scoped name module while closing out an array member definition with a constant symbol dimension.");
		} else if (this.typedefStack.empty() || !(this.typedefStack.peek() instanceof IdlArrayType)) {
			this.scopedNameModule = null;
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Inconsistent state for type definition stack while closing out an array member definition with a constant symbol dimension.");
		} else {
			IdlArrayType arrayType = (IdlArrayType)this.typedefStack.peek();
			String constantName = ctx.scopedName().getStop().getText();
			IdlConstantExpression theConst = this.scopedNameModule.resolveConstantName(constantName);
			if (theConst == null) {
				this.printErrorMessage(
						ctx.getStart().getLine(), 
						ctx.getStart().getCharPositionInLine(), 
						"Unknown constant \"" + constantName + "\".");
			} else if (!(theConst.getConstantValue() instanceof Long)) {
				this.printErrorMessage(
						ctx.getStart().getLine(), 
						ctx.getStart().getCharPositionInLine(), 
						"Constant used for array dimensions must be an integer.");
			} else {
				arrayType.setArraySize(((Long)theConst.getConstantValue()).intValue());
				this.typedefStack.pop(); // Popping the array type that was already stored in the topic member.
				IdlStructureField aField = (IdlStructureField)this.typedefStack.pop();
				this.currentFieldReceiver.addStructureField(aField);
			}
			this.scopedNameModule = null;
		}
	}
	
	@Override public void enterUnionDefinition(@NotNull DdsJsIdlParser.UnionDefinitionContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Module stack underflow while starting union definition.");
		} else if ((this.currentFieldReceiver != null) || (this.currentUnion != null)) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Definition of unions inside other unions or data structures not supported at this time.");
		} else {
			IdlUnionDefinition aUnion = new IdlUnionDefinition(ctx.IDENTIFIER().getText(), null, this.moduleStack.peek());
			this.currentUnion = aUnion;
			this.typedefStack.push(aUnion);
		}
	}
	
	@Override public void exitUnionDefinition(@NotNull DdsJsIdlParser.UnionDefinitionContext ctx) {
		if (this.moduleStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Module stack underflow while closing out union definition.");
		} else if (this.currentUnion == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Closing out union definition that was never started.");
		} else {
			this.moduleStack.peek().addUnionDefinition(this.currentUnion);
			this.currentUnion = null;
			this.typedefStack.pop();
		}
	}
	
	@Override public void enterUnionCaseDefinition(@NotNull DdsJsIdlParser.UnionCaseDefinitionContext ctx) {
		if (this.currentFieldReceiver != null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Start of a union case definition outside of a union definition.");
		} else {
			IdlUnionCase newCase = new IdlUnionCase(ctx.IDENTIFIER().getText());
			this.currentFieldReceiver = newCase;
		}
	}
	
	@Override public void exitUnionCaseDefinition(@NotNull DdsJsIdlParser.UnionCaseDefinitionContext ctx) {
		if (this.currentUnion == null) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Closing out union case definition outside of a union definition.");
		} else if ((this.currentFieldReceiver == null) || !(this.currentFieldReceiver instanceof IdlUnionCase)) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Inconsistent state of the field receiver while closing out a union case definition.");
		} else {
			IdlUnionCase theCase = (IdlUnionCase)this.currentFieldReceiver;
			this.currentUnion.addUnionCase(theCase);
			this.currentFieldReceiver = null;
		}
	}
	
	@Override public void enterBooleanTypeDescription(@NotNull DdsJsIdlParser.BooleanTypeDescriptionContext ctx) {
		if (this.typedefStack.empty()) {
			this.printErrorMessage(
					ctx.getStart().getLine(), 
					ctx.getStart().getCharPositionInLine(), 
					"Internal error: Type definition stack underflow while starting boolean type description.");
		} else try {
			this.typedefStack.peek().setTypeDefinition(new IdlPrimitiveType(IdlPrimitiveType.Primitive.BOOLEAN));
		} catch(RuntimeException ex) {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					ex.getMessage());
		}
	}
	
	protected Long integerValueContextToValue(DdsJsIdlParser.IntegerValueContext ctx) {
		Long result = null;
		if (ctx.DECIMAL_VALUE() != null) {
			result = Long.parseLong(ctx.DECIMAL_VALUE().getText());
		} else if (ctx.HEXADECIMAL_VALUE() != null) {
			result = Long.parseLong(ctx.HEXADECIMAL_VALUE().getText().substring(2), 16);
		} else if (ctx.OCTAL_VALUE() != null) {
			result = Long.parseLong(ctx.OCTAL_VALUE().getText().substring(1), 8);
		} else if (ctx.BINARY_VALUE() != null) {
			result = Long.parseLong(ctx.BINARY_VALUE().getText().substring(1), 2);
		} else {
			this.printErrorMessage(
					ctx.getStart().getLine(),
					ctx.getStart().getCharPositionInLine(),
					"Internal error: Unknown integer type \"" + ctx.getText() + "\".");
		}
		
		return result;
	}
	
	protected void printErrorMessage(int lineNumber, int column, String message) {
		System.err.println(
				"\"" +
				this.fileNameStack.peek() + 
				"\", line " + 
				Integer.toString(lineNumber) + 
				"[" + 
				Integer.toString(column) + 
				"]: " + 
				message);
		this.semanticErrorCount++;
	}

	protected void printWarningMessage(int lineNumber, int column, String message) {
		System.err.println(
				"\"" +
				this.fileNameStack.peek() +
				"\", line " +
				Integer.toString(lineNumber) +
				"[" +
				Integer.toString(column) +
				"]:warning:" +
				message);
	}
	
	@Override
	public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex,
			boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
	}

	@Override
	public void reportAttemptingFullContext(Parser arg0, DFA arg1, int arg2,
			int arg3, BitSet arg4, ATNConfigSet arg5) {
	}

	@Override
	public void reportContextSensitivity(Parser arg0, DFA arg1, int arg2,
			int arg3, int arg4, ATNConfigSet arg5) {
	}

	@Override
	public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int lineNumber,
			int column, String message, RecognitionException ex) {
		this.printErrorMessage(lineNumber, column, message);
	}
}
